{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nLeftFront = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\nRightFront = Motor(Ports.PORT10, GearSetting.RATIO_18_1, True)\nLeftRear = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)\nRightRear = Motor(Ports.PORT9, GearSetting.RATIO_18_1, True)\nDistance = Distance(Ports.PORT19)\n# vex-vision-config:begin\nVision__REDBALL = Signature(1, 8623, 10263, 9443,-1553, -915, -1234,3, 0)\nVision__YELLOWBALL = Signature(2, 675, 1575, 1125,-4767, -4181, -4474,2.5, 0)\nVision__SIG_3 = Signature(3, 0, 0, 0,0, 0, 0,3, 0)\nVision = Vision(Ports.PORT20, 50, Vision__REDBALL, Vision__YELLOWBALL, Vision__SIG_3)\n# vex-vision-config:end\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\nmyVariable = 0\n\ndef when_started1():\n    global myVariable\n    # Set up motors\n    LeftFront.set_stopping(BRAKE)\n    RightFront.set_stopping(BRAKE)\n    LeftRear.set_stopping(BRAKE)\n    RightRear.set_stopping(BRAKE)\n\n    # sert motor speeds\n    LeftFront.set_velocity(35, PERCENT)\n    RightFront.set_velocity(35, PERCENT)\n    LeftRear.set_velocity(35, PERCENT)\n    RightRear.set_velocity(35, PERCENT)\n\n    # set drian display\n    brain.screen.set_font(FontType.MONO20)\n    brain.screen.set_pen_color(Color.BLUE)\n    brain.screen.print(\"Starting\")\n    brain.screen.next_row()\n    wait(1, SECONDS)\n\ndef main():\n    distanceToObject = 0\n    # 1 turn = 12 inches in forward and reverse\n    # 1 turn = 12 inches in diagonal\n    # 1.15 turns = 90 degrees in rotation\n    \n    turns = 1\n    inchesToMove = 12\n\n    when_started1()\n    visionObject = Vision.take_snapshot(Vision__REDBALL)\n    result = isinstance(visionObject, tuple)\n    if result:\n        brain.screen.print(\"A Tuple with %d objects was returned\" % (len(visionObject)))\n        brain.screen.next_row()\n        if (len(visionObject)) > 1:\n            for i in range(len(visionObject)): \n                brain.screen.print(\"%d Center X:  %d\"% (i+1, visionObject[i].centerX))\n                brain.screen.next_row()\n                brain.screen.print(\"%d The width of the object is: %.2f\" % (i+1, visionObject[i].width))\n                brain.screen.next_row()\n                #Calculate angle\n                angle1=math.atan(((158-visionObject[i].centerX)/158)*math.tan(33*math.pi/180))\n                angle1=angle1*180/math.pi\n                brain.screen.print(\"%d The angle to the object is: %.2f\" % (i+1, angle1))\n                brain.screen.next_row()\n\n    elif visionObject is not None:\n        width = Vision.largest_object().width\n        brain.screen.print(\"The width of the object is: %.2f\" % width)\n        brain.screen.next_row()\n        angle1=math.atan(((158-Vision.largest_object().centerX)/158)*math.tan(33*math.pi/180))\n        angle1=angle1*180/math.pi\n        brain.screen.print(\"The angle to the object is: %.2f\" % angle1)\n    else:\n        brain.screen.print(\"No Object Detected\")\n        brain.screen.next_row()      \n    wait(10, SECONDS)\n\n    if Distance.is_object_detected():\n        distanceToObject = Distance.object_distance(INCHES)\n        brain.screen.print(\"The distance to the object is: %.2f inches\" % distanceToObject)\n        brain.screen.next_row()\n    wait(3, SECONDS)\n\n    for repeat_count in range(5): \n   \n        brain.screen.clear_screen()\n        brain.screen.set_cursor(1, 1)\n\n        # Take a snapshot with the Vision Sensor with the specified signature and store the object data into a variable\n        vision_object = Vision.take_snapshot(Vision__REDBALL)\n\n        # Check the variable to see if a valid object was detected when the snapshot was captured\n        # If yes, print the data\n        if vision_object is not None:\n            brain.screen.print(\"Center X: \",Vision.largest_object().centerX)\n            brain.screen.next_row()\n\n            brain.screen.print(\"Center Y: \", Vision.largest_object().centerY)\n            brain.screen.next_row()\n\n            brain.screen.print(\"Angle: \", Vision.largest_object().angle)\n            brain.screen.next_row()\n\n            # Take a new snapshot every 2 seconds\n            wait(2.0, SECONDS)\n        else:\n            brain.screen.print(\"No Object Detected\")\n\n\n# call the main module\nmain()\n","textLanguage":"python","rconfig":[{"port":[1],"name":"LeftFront","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[10],"name":"RightFront","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[2],"name":"LeftRear","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[9],"name":"RightRear","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[19],"name":"Distance","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22},{"port":[20],"name":"Vision","customName":true,"deviceType":"Vision","deviceClass":"vision","setting":{"config":"{\"config\":{\"brightness\":50,\"signatures\":[{\"name\":\"REDBALL\",\"parameters\":{\"uMin\":8623,\"uMax\":10263,\"uMean\":9443,\"vMin\":-1553,\"vMax\":-915,\"vMean\":-1234,\"rgb\":1,\"type\":0,\"name\":\"REDBALL\"},\"range\":3},{\"name\":\"YELLOWBALL\",\"parameters\":{\"uMin\":675,\"uMax\":1575,\"uMean\":1125,\"vMin\":-4767,\"vMax\":-4181,\"vMean\":-4474,\"rgb\":1,\"type\":0,\"name\":\"YELLOWBALL\"},\"range\":2.5},{\"name\":\"SIG_3\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_3\"},\"range\":3},{\"name\":\"SIG_4\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_4\"},\"range\":2.5},{\"name\":\"SIG_5\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_5\"},\"range\":2.5},{\"name\":\"SIG_6\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_6\"},\"range\":2.5},{\"name\":\"SIG_7\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_7\"},\"range\":2.5}],\"codes\":[]}}","isConfigured":"false"},"triportSourcePort":22}],"slot":0,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.4","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}