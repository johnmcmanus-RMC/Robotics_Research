{"mode":"Text","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\nLeftFront = Motor(Ports.PORT1, GearSetting.RATIO_18_1, False)\nRightFront = Motor(Ports.PORT10, GearSetting.RATIO_18_1, True)\nLeftRear = Motor(Ports.PORT2, GearSetting.RATIO_18_1, False)\nRightRear = Motor(Ports.PORT9, GearSetting.RATIO_18_1, True)\nDistance = Distance(Ports.PORT19)\n# vex-vision-config:begin\nVision__REDBALL = Signature(1, 8623, 10263, 9443,-1553, -915, -1234,3, 0)\nVision__YELLOWBALL = Signature(2, 675, 1575, 1125,-4767, -4181, -4474,2.5, 0)\nVision__SIG_3 = Signature(3, 0, 0, 0,0, 0, 0,3, 0)\nVision = Vision(Ports.PORT20, 50, Vision__REDBALL, Vision__YELLOWBALL, Vision__SIG_3)\n# vex-vision-config:end\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\n\nmyVariable = 0\n\ndef when_started1():\n    # Define Global variables\n    # 1 turn = 12 inches in forward, reverse, and drift (left and right)\n    # 1 turn = 6 inches (forawrd) in diagonal\n    # 1 turn = 8.485 inches (along diagonal) in diagonal\n    # 1.15 turns = 90 degrees in rotation\n \n    global turns\n    global inchesToMove\n    global degreesToTurn\n\n    # Set up motors\n    LeftFront.set_stopping(BRAKE)\n    RightFront.set_stopping(BRAKE)\n    LeftRear.set_stopping(BRAKE)\n    RightRear.set_stopping(BRAKE)\n\n    # set motor speeds\n    LeftFront.set_velocity(45, PERCENT)\n    RightFront.set_velocity(45, PERCENT)\n    LeftRear.set_velocity(45, PERCENT)\n    RightRear.set_velocity(45, PERCENT)\n\n    # set brain display\n    brain.screen.set_font(FontType.MONO20)\n    brain.screen.set_pen_color(Color.BLUE)\n    brain.screen.print(\"Starting\")\n    brain.screen.next_row()\n    wait(1, SECONDS)\n\n# Drive Forward: Drive forward\n# All motors spin forward\n# @parameter inches: number of inches\ndef driveForward(inches):\n    numTurns = inches / 12.0\n    brain.screen.print(\"Drive Forward\")\n    brain.screen.next_row()\n    LeftFront.spin_for(FORWARD, numTurns, TURNS, wait=False)\n    RightFront.spin_for(FORWARD, numTurns, TURNS, wait=False)\n    LeftRear.spin_for(FORWARD, numTurns, TURNS, wait=False)\n    RightRear.spin_for(FORWARD, numTurns, TURNS, wait=False)\n    \n    # Wait for the motors to complete their spin\n    while not LeftFront.is_done(): \n        pass\n    return()\n\n# Drive Reverse: Drive forward\n# All motors spin reverse\n# @parameter inches: number of inches to move\ndef driveReverse(inches):\n    numTurns = inches / 12.0 # one turn of the motor = 12.0 inches movement\n    brain.screen.print(\"Drive Reverse\")\n    brain.screen.next_row()\n    LeftFront.spin_for(REVERSE, numTurns, TURNS, wait=False)\n    RightFront.spin_for(REVERSE, numTurns, TURNS, wait=False)\n    LeftRear.spin_for(REVERSE, numTurns, TURNS, wait=False)\n    RightRear.spin_for(REVERSE, numTurns, TURNS, wait=False)\n    \n    # Wait for the motors to complete their spin\n    while not LeftFront.is_done(): \n        pass\n    return()\n\n# Turn right: Tank turn, clockwise\n# Left front and left rear spin forward\n# Right front and right rear spin in reverse\n# @parameter degrees: number of degrees (clockwise) to rotate\ndef turnRight(degrees):\n    LeftFront.set_stopping(HOLD)\n    RightFront.set_stopping(HOLD)\n    LeftRear.set_stopping(HOLD)\n    RightRear.set_stopping(HOLD)\n    temp = degrees / 90.0 \n    numTurns = temp * 1.16 # 1.16 rotations required for 90 degree turn\n    brain.screen.print(\"Turn Right\")\n    brain.screen.next_row()\n    LeftFront.spin_for(FORWARD, numTurns, TURNS, wait=False)\n    LeftRear.spin_for(FORWARD, numTurns, TURNS, wait=False)\n    RightFront.spin_for(REVERSE, numTurns, TURNS, wait=False)\n    RightRear.spin_for(REVERSE, numTurns, TURNS, wait=False)\n    \n    # Wait for the motors to complete their spin\n    while not LeftFront.is_done(): \n        pass\n    return()\n\n# Turn left: tank turn, counter clockwise\n# Left front and left rear spin reverse\n# Right front and right rear spin forward\n# @parameter degrees: number of degrees (counter-clockwise) to rotate\ndef turnLeft(degrees):\n    LeftFront.set_stopping(HOLD)\n    RightFront.set_stopping(HOLD)\n    LeftRear.set_stopping(HOLD)\n    RightRear.set_stopping(HOLD)\n    temp = degrees / 90.0 \n    numTurns = temp * 1.16 # 1.16 rotations required for 90 degree turn\n    brain.screen.print(\"TurnLeft\")\n    brain.screen.next_row()\n    RightFront.spin_for(FORWARD, numTurns, TURNS, wait=False)\n    RightRear.spin_for(FORWARD, numTurns, TURNS, wait=False)\n    LeftFront.spin_for(REVERSE, numTurns, TURNS, wait=False)\n    LeftRear.spin_for(REVERSE, numTurns, TURNS, wait=False)\n    \n    # Wait for the motors to complete their spin\n    while not LeftFront.is_done(): \n        pass\n    return()\n\n# Drift Right: Move the robot right\n# Left front and right rear spin forward\n# Right front and left rear spin in reverse\n# @parameter inches: number of inches to move right\ndef driftRight(inches):\n    numTurns = inches /12.0 # one turn of the motor = 12.0 inches movement\n    brain.screen.print(\"Drift Right\")\n    brain.screen.next_row()\n    LeftFront.spin_for(FORWARD, numTurns, TURNS, wait=False)\n    RightFront.spin_for(REVERSE, numTurns, TURNS, wait=False)\n    LeftRear.spin_for(REVERSE, numTurns, TURNS, wait=False)\n    RightRear.spin_for(FORWARD, numTurns, TURNS, wait=False)\n    \n    # Wait for the motors to complete their spin\n    while not LeftFront.is_done(): \n        pass\n    return()\n\n# Drift Left: Move the robot left\n# Left front and right rear spin in reverse\n# Right front and left rear spin forward\n# @parameter inches: number of inches to move left\ndef driftLeft(inches):\n    numTurns = inches /12.0 # one turn of the motor = 12.0 inches movement\n    brain.screen.print(\"Drift Left\")\n    brain.screen.next_row()\n    LeftFront.spin_for(REVERSE, numTurns, TURNS, wait=False)\n    RightFront.spin_for(FORWARD, numTurns, TURNS, wait=False)\n    LeftRear.spin_for(FORWARD, numTurns, TURNS, wait=False)\n    RightRear.spin_for(REVERSE, numTurns, TURNS, wait=False)\n        \n    # Wait for the motors to complete their spin\n    while not LeftFront.is_done(): \n        pass\n    return()\n\n# Diagonal Right: Move the robot left\n# Left front and right rear spin forward\n# @parameter numTurns: number of inches to move\n# @parameter direction: FORWARD by default, can specifiy REVERSE\ndef diagonalRight(inches,direction=FORWARD):\n\n    numTurns = inches / 6.0 # one turn of the motor = 6.0 inches movement\n    brain.screen.print(\"Diagonal Right\")\n    brain.screen.next_row()\n    LeftFront.spin_for(direction, numTurns, TURNS, wait=False)\n    RightRear.spin_for(direction, numTurns, TURNS, wait=False)\n        \n    # Wait for the motors to complete their spin\n    while not LeftFront.is_done(): \n        pass\n    return()\n\n# Diagonal Left: Move the robot right\n# Right front and left rear spin forward\n# @parameter inches: number of inches to move\n# @parameter direction: FORWARD by default, can specifiy REVERSE\ndef diagonalLeft(inches, direction=FORWARD):\n    numTurns = inches / 6.0 # one turn of the motor = 6.0 inches movement\n    brain.screen.print(\"Diagonal Left\")\n    brain.screen.next_row()\n    RightFront.spin_for(direction, numTurns, TURNS, wait=False)\n    LeftRear.spin_for(direction, numTurns, TURNS, wait=False)\n\n    # Wait for the motors to complete their spin\n    while not RightFront.is_done(): \n        pass\n    return()\n\n# Stop Motors: Stops all 4 motors\ndef stopMotors():\n    RightFront.stop()\n    LeftFront.stop()\n    RightRear.stop()\n    LeftRear.stop()\n    return()\n\n# diagonalAtAngle: Move the robot a specifed distance and at a specified angle\n# @parameter speed: velocity percent of the main motor\n# @parameter angle: angle of motion (0=straight forward, 90=left, 180=reverse, 270=right, etc.)\n# @parameter inches: number of inches to move\n# @parameter direction: Input either 'Axis' or 'Diagonal' By default measure distance along axis. Can change to measure along diagonal\ndef diagonalAtAngle(speed, angle, inches,direction='Axis' ):\n    # Change the motor speeds based on the angle\n    diff=(angle%90)-45 # Determine if the angle is greater or less than 45\n    proportion = abs(diff)/45 # Calculate the proportion of the speed of the secondary pair of motors\n    if direction.lower()=='axis':\n        numTurns = inches / (6 +proportion*6) # one turn of the motor = 6 inches diagonal movement up to 12 inches of straight movement\n    elif direction.lower() == 'diagonal':\n        numTurns = inches / (8.485 +proportion*3.515) # one turn of the motor = 8.485 inches diagonal movement up to 12 inches of straight movement\n    else:\n        brain.screen.print(\"Invalid direction\")\n        return()\n    # Validate angle and call the appropriate helper function based on the angle\n    if angle < 0 or angle >=360:\n        brain.screen.print(\"Invalid Angle\")\n    elif angle <= 90:\n        brain.screen.print(\"Forward Left Diagonal\")\n        brain.screen.next_row()\n        # Set LB and RF motors (main motors) at standard speed\n        RightFront.set_velocity(speed, PERCENT)\n        LeftRear.set_velocity(speed, PERCENT)\n        # Set LF and RB motors (secondary motors) according to the angle\n        LeftFront.set_velocity(proportion*speed, PERCENT)\n        RightRear.set_velocity(proportion*speed, PERCENT)\n\n        # Determine direction of secondary pair\n        if diff > 0:\n            direction = REVERSE\n        elif diff==-45 and angle==90:\n            direction = REVERSE\n        else:\n            direction = FORWARD \n        \n        # Start spinning main motors\n        RightFront.spin_for(FORWARD, numTurns, TURNS, wait=False)\n        LeftRear.spin_for(FORWARD, numTurns, TURNS, wait=False)\n        # Start spinning secondary motors       \n        LeftFront.spin_for(direction, numTurns, TURNS, wait=False)\n        RightRear.spin_for(direction, numTurns, TURNS, wait=False)\n        \n        # Wait for the motors to complete their spin\n        while not LeftRear.is_done(): \n            pass\n        stopMotors()\n\n    elif angle < 180:\n        brain.screen.print(\"Reverse Left Diagonal\")\n        brain.screen.next_row()\n        # Set LF and RB motors (main motors) at standard speed\n        LeftFront.set_velocity(proportion*speed, PERCENT)\n        RightRear.set_velocity(proportion*speed, PERCENT)\n        # Set LB and RF motors (secondary motors) according to the angle\n        RightFront.set_velocity(proportion*speed, PERCENT)\n        LeftRear.set_velocity(proportion*speed, PERCENT)\n\n        # Determine direction of secondary pair\n        if diff > 0:\n            direction = REVERSE\n        else:\n            direction = FORWARD \n        \n        # Start spinning main motors\n        LeftFront.spin_for(FORWARD, numTurns, TURNS, wait=False)\n        RightRear.spin_for(FORWARD, numTurns, TURNS, wait=False)\n        # Start spinning secondary motors       \n        RightFront.spin_for(direction, numTurns, TURNS, wait=False)\n        LeftRear.spin_for(direction, numTurns, TURNS, wait=False)\n        # Wait for the motors to complete their spin\n        while not RightRear.is_done(): \n            pass\n        stopMotors()\n\n    elif angle <= 270:\n        brain.screen.print(\"Reverse Right Diagonal\")\n        brain.screen.next_row()\n        # Set LB and RF motors (main motors) at standard speed\n        RightFront.set_velocity(speed, PERCENT)\n        LeftRear.set_velocity(speed, PERCENT)\n        # Set LF and RB motors (secondary motors) according to the angle\n        LeftFront.set_velocity(proportion*speed, PERCENT)\n        RightRear.set_velocity(proportion*speed, PERCENT)\n\n        # Determine direction of secondary pair\n        if diff > 0:\n            direction = FORWARD\n        elif diff== -45 and angle==270:\n            direction = FORWARD\n        else:\n            direction = REVERSE \n        \n        # Start spinning main motors\n        RightFront.spin_for(REVERSE, numTurns, TURNS, wait=False)\n        LeftRear.spin_for(REVERSE, numTurns, TURNS, wait=False)\n        # Start spinning secondary motors       \n        LeftFront.spin_for(direction, numTurns, TURNS, wait=False)\n        RightRear.spin_for(direction, numTurns, TURNS, wait=False)\n        \n        # Wait for the motors to complete their spin\n        while not LeftRear.is_done(): \n            pass\n        stopMotors()\n\n    else:\n        brain.screen.print(\"Forward Left Diagonal\")\n        brain.screen.next_row()\n        # Set LF and RB motors (main motors) at standard speed\n        LeftFront.set_velocity(speed, PERCENT)\n        RightRear.set_velocity(speed, PERCENT)\n        # Set LB and RF motors (secondary motors) according to the angle\n        RightFront.set_velocity(proportion*speed, PERCENT)\n        LeftRear.set_velocity(proportion*speed, PERCENT)\n\n        # Determine direction of secondary pair\n        if diff > 0:\n            direction = FORWARD\n        else:\n            direction = REVERSE \n        \n        # Start spinning main motors\n        LeftFront.spin_for(FORWARD, numTurns, TURNS, wait=False)\n        RightRear.spin_for(FORWARD, numTurns, TURNS, wait=False)\n        # Start spinning secondary motors       \n        RightFront.spin_for(direction, numTurns, TURNS, wait=False)\n        LeftRear.spin_for(direction, numTurns, TURNS, wait=False)\n        # Wait for the motors to complete their spin\n        while not RightRear.is_done(): \n            pass\n        stopMotors()\n\n    # Reset all velocities to 35%\n    LeftFront.set_velocity(35, PERCENT)\n    RightRear.set_velocity(35, PERCENT)\n    RightFront.set_velocity(35, PERCENT)\n    LeftRear.set_velocity(35, PERCENT)\n    return()\n\n# Test Angle: Helper function to measure the distance to an object before and after traveling a set distance. It can be used to measure how accurate the movements at an angle are.\n#@ parameter angleToMove: The angle at which to move\n#@ parameter inchesToMove: The number of inches to move\n#@ parameter direction: The direction to measure distance. Along axis by default. Can specify 'Diagonal' to measure distance along the diagonal that the robot travels\ndef TestAngle(angleToMove, inchesToMove, direction='Axis'):\n    x1=Distance.object_distance(INCHES)\n    diagonalAtAngle(35, angleToMove, inchesToMove, direction)\n    x2=Distance.object_distance(INCHES)\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1,1)\n    brain.screen.print(x1)\n    brain.screen.next_row()\n    brain.screen.print(x2)\n    brain.screen.next_row()\n    if direction.lower() == 'axis':\n        if (angleToMove>45 and angleToMove <135) or (angleToMove>225 and angleToMove <315): # Angles in which the distance to the wall should not change a constant ammount\n            brain.screen.print(inchesToMove*math.cos(angleToMove/ 180.0 * math.pi)-(x1-x2))\n        else:\n            brain.screen.print((inchesToMove)-(x1-x2))\n    elif direction.lower() == 'diagonal':\n        brain.screen.print(inchesToMove*math.cos(angleToMove/ 180.0 * math.pi)-(x1-x2))\n    else:\n        brain.screen.print('Invalid Direction')\n    wait(10, SECONDS)\n    return\n\ndef main():\n    # Initialize the number of inches to move\n    # inchesToMove = 12\n    # angleToMove = 0\n \n    # TestAngle(0,12,'Diagonal')\n\n    # TestAngle(45,12,'Axis')\n\n    # TestAngle(45,12,'Diagonal')\n\n    # Vision.take_snapshot(Vision__REDBALL)\n    # brain.screen.print(Vision.largest_object().centerX)\n    # angle1=(160-Vision.largest_object().centerX)/160*33\n    # if angle1 < 0:\n    #     angle1=360-angle1\n    # while not Distance.is_object_detected():\n    #     diagonalAtAngle(35, angle1, 12, 'diagonal')\n    # brain.screen.print('Object Found')\n\n\n\n    # Slowly Spin until a Red Object is Detected\n    vexcode_visionsensor_objects = Vision.take_snapshot(Vision__REDBALL)\n    wait(2, SECONDS)\n    while not (vexcode_visionsensor_objects and len(vexcode_visionsensor_objects) > 0):\n        driveForward(6)\n        vexcode_visionsensor_objects = Vision.take_snapshot(Vision__REDBALL)\n        wait(1, SECONDS)\n        wait(5, MSEC)\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n    brain.screen.print(\"Red Object Found\")\n    brain.screen.next_row()\n    wait(2, SECONDS)\n    vexcode_visionsensor_objects = Vision.take_snapshot(Vision__REDBALL)\n    wait(1, SECONDS)\n    brain.screen.print(len(vexcode_visionsensor_objects) if vexcode_visionsensor_objects else 0,)\n    brain.screen.next_row()\n    center = Vision.largest_object().centerX\n    brain.screen.print(center)\n    brain.screen.next_row()\n    # Center the Claw on the Object\n    angle1=math.atan(((158-center)/158)*math.tan(33*math.pi/180))\n    angle1=angle1*180/math.pi\n    brain.screen.print(angle1)\n    if angle1 < 0:\n        turnRight(abs(angle1))\n    else:\n        turnLeft(abs(angle1))\n\n    brain.screen.clear_screen()\n    brain.screen.set_cursor(1, 1)\n    wait(1, SECONDS)\n    vexcode_visionsensor_objects = Vision.take_snapshot(Vision__REDBALL)\n    wait(1, SECONDS)\n    center = Vision.largest_object().centerX\n    brain.screen.print(center)\n    brain.screen.next_row()\n    #angle1=(158-center)/158*33\n    angle1=math.atan(((158-center)/158)*math.tan(33*math.pi/180))\n    angle1=angle1*180/math.pi\n    brain.screen.print(angle1)\n    brain.screen.next_row()\n    brain.screen.print(Distance.object_distance(INCHES))\n    wait(5, SECONDS)\n    # while not Distance.is_object_detected():\n    #     diagonalAtAngle(35, angle1, 6, 'diagonal')\n    #     wait(1,SECONDS)\n    # brain.screen.print('Object Found')\n\n# call the main module\nmain()\n","textLanguage":"python","rconfig":[{"port":[1],"name":"LeftFront","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[10],"name":"RightFront","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[2],"name":"LeftRear","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"false","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[9],"name":"RightRear","customName":true,"deviceType":"Motor","deviceClass":"motor","setting":{"reversed":"true","fwd":"forward","rev":"reverse","gear":"ratio18_1"},"triportSourcePort":22},{"port":[19],"name":"Distance","customName":true,"deviceType":"Distance","deviceClass":"distance","setting":{},"triportSourcePort":22},{"port":[20],"name":"Vision","customName":true,"deviceType":"Vision","deviceClass":"vision","setting":{"config":"{\"config\":{\"brightness\":50,\"signatures\":[{\"name\":\"REDBALL\",\"parameters\":{\"uMin\":8623,\"uMax\":10263,\"uMean\":9443,\"vMin\":-1553,\"vMax\":-915,\"vMean\":-1234,\"rgb\":1,\"type\":0,\"name\":\"REDBALL\"},\"range\":3},{\"name\":\"YELLOWBALL\",\"parameters\":{\"uMin\":675,\"uMax\":1575,\"uMean\":1125,\"vMin\":-4767,\"vMax\":-4181,\"vMean\":-4474,\"rgb\":1,\"type\":0,\"name\":\"YELLOWBALL\"},\"range\":2.5},{\"name\":\"SIG_3\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_3\"},\"range\":3},{\"name\":\"SIG_4\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_4\"},\"range\":2.5},{\"name\":\"SIG_5\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_5\"},\"range\":2.5},{\"name\":\"SIG_6\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_6\"},\"range\":2.5},{\"name\":\"SIG_7\",\"parameters\":{\"uMin\":0,\"uMax\":0,\"uMean\":0,\"vMin\":0,\"vMax\":0,\"vMean\":0,\"rgb\":0,\"type\":0,\"name\":\"SIG_7\"},\"range\":2.5}],\"codes\":[]}}","isConfigured":"false"},"triportSourcePort":22}],"slot":1,"platform":"V5","sdkVersion":"20220726.10.00.00","appVersion":"3.0.3","minVersion":"3.0.0","fileFormat":"1.2.0","icon":"","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false,"target":"Physical"}